{"ast":null,"code":"\"use strict\";\n\nvar root_1 = require('./root');\n\nvar isArrayLike_1 = require('./isArrayLike');\n\nvar isPromise_1 = require('./isPromise');\n\nvar isObject_1 = require('./isObject');\n\nvar Observable_1 = require('../Observable');\n\nvar iterator_1 = require('../symbol/iterator');\n\nvar InnerSubscriber_1 = require('../InnerSubscriber');\n\nvar observable_1 = require('../symbol/observable');\n\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n  var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\n  if (destination.closed) {\n    return null;\n  }\n\n  if (result instanceof Observable_1.Observable) {\n    if (result._isScalar) {\n      destination.next(result.value);\n      destination.complete();\n      return null;\n    } else {\n      destination.syncErrorThrowable = true;\n      return result.subscribe(destination);\n    }\n  } else if (isArrayLike_1.isArrayLike(result)) {\n    for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n      destination.next(result[i]);\n    }\n\n    if (!destination.closed) {\n      destination.complete();\n    }\n  } else if (isPromise_1.isPromise(result)) {\n    result.then(function (value) {\n      if (!destination.closed) {\n        destination.next(value);\n        destination.complete();\n      }\n    }, function (err) {\n      return destination.error(err);\n    }).then(null, function (err) {\n      // Escaping the Promise trap: globally throw unhandled errors\n      root_1.root.setTimeout(function () {\n        throw err;\n      });\n    });\n    return destination;\n  } else if (result && typeof result[iterator_1.iterator] === 'function') {\n    var iterator = result[iterator_1.iterator]();\n\n    do {\n      var item = iterator.next();\n\n      if (item.done) {\n        destination.complete();\n        break;\n      }\n\n      destination.next(item.value);\n\n      if (destination.closed) {\n        break;\n      }\n    } while (true);\n  } else if (result && typeof result[observable_1.observable] === 'function') {\n    var obs = result[observable_1.observable]();\n\n    if (typeof obs.subscribe !== 'function') {\n      destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n    } else {\n      return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n    }\n  } else {\n    var value = isObject_1.isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n    var msg = \"You provided \" + value + \" where a stream was expected.\" + ' You can provide an Observable, Promise, Array, or Iterable.';\n    destination.error(new TypeError(msg));\n  }\n\n  return null;\n}\n\nexports.subscribeToResult = subscribeToResult;","map":{"version":3,"sources":["../../src/util/subscribeToResult.ts"],"names":[],"mappings":";;AAAA,IAAA,MAAA,GAAA,OAAA,CAAqB,QAArB,CAAA;;AACA,IAAA,aAAA,GAAA,OAAA,CAA4B,eAA5B,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAA0B,aAA1B,CAAA;;AACA,IAAA,UAAA,GAAA,OAAA,CAAyB,YAAzB,CAAA;;AAEA,IAAA,YAAA,GAAA,OAAA,CAA4C,eAA5C,CAAA;;AACA,IAAA,UAAA,GAAA,OAAA,CAA4C,oBAA5C,CAAA;;AAEA,IAAA,iBAAA,GAAA,OAAA,CAAgC,oBAAhC,CAAA;;AAEA,IAAA,YAAA,GAAA,OAAA,CAAgD,sBAAhD,CAAA;;AAMA,SAAA,iBAAA,CAAqC,eAArC,EACqC,MADrC,EAEqC,UAFrC,EAGqC,UAHrC,EAGwD;AACtD,MAAI,WAAW,GAAoB,IAAI,iBAAA,CAAA,eAAJ,CAAoB,eAApB,EAAqC,UAArC,EAAiD,UAAjD,CAAnC;;AAEA,MAAI,WAAW,CAAC,MAAhB,EAAwB;AACtB,WAAO,IAAP;AACD;;AAED,MAAI,MAAM,YAAY,YAAA,CAAA,UAAtB,EAAkC;AAChC,QAAI,MAAM,CAAC,SAAX,EAAsB;AACpB,MAAA,WAAW,CAAC,IAAZ,CAAuB,MAAO,CAAC,KAA/B;AACA,MAAA,WAAW,CAAC,QAAZ;AACA,aAAO,IAAP;AACD,KAJD,MAIO;AACL,MAAA,WAAW,CAAC,kBAAZ,GAAiC,IAAjC;AACA,aAAO,MAAM,CAAC,SAAP,CAAiB,WAAjB,CAAP;AACD;AACF,GATD,MASO,IAAI,aAAA,CAAA,WAAA,CAAY,MAAZ,CAAJ,EAAyB;AAC9B,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,GAAG,GAAG,MAAM,CAAC,MAA7B,EAAqC,CAAC,GAAG,GAAJ,IAAW,CAAC,WAAW,CAAC,MAA7D,EAAqE,CAAC,EAAtE,EAA0E;AACxE,MAAA,WAAW,CAAC,IAAZ,CAAiB,MAAM,CAAC,CAAD,CAAvB;AACD;;AACD,QAAI,CAAC,WAAW,CAAC,MAAjB,EAAyB;AACvB,MAAA,WAAW,CAAC,QAAZ;AACD;AACF,GAPM,MAOA,IAAI,WAAA,CAAA,SAAA,CAAU,MAAV,CAAJ,EAAuB;AAC5B,IAAA,MAAM,CAAC,IAAP,CACE,UAAC,KAAD,EAAM;AACJ,UAAI,CAAC,WAAW,CAAC,MAAjB,EAAyB;AACvB,QAAA,WAAW,CAAC,IAAZ,CAAsB,KAAtB;AACA,QAAA,WAAW,CAAC,QAAZ;AACD;AACF,KANH,EAOE,UAAC,GAAD,EAAS;AAAK,aAAA,WAAW,CAAC,KAAZ,CAAA,GAAA,CAAA;AAAsB,KAPtC,EASC,IATD,CASM,IATN,EASY,UAAC,GAAD,EAAS;AACnB;AACA,MAAA,MAAA,CAAA,IAAA,CAAK,UAAL,CAAgB,YAAA;AAAQ,cAAM,GAAN;AAAY,OAApC;AACD,KAZD;AAaA,WAAO,WAAP;AACD,GAfM,MAeA,IAAI,MAAM,IAAI,OAAO,MAAM,CAAC,UAAA,CAAA,QAAD,CAAb,KAAmC,UAAjD,EAA6D;AAClE,QAAM,QAAQ,GAAQ,MAAM,CAAC,UAAA,CAAA,QAAD,CAAN,EAAtB;;AACA,OAAG;AACD,UAAI,IAAI,GAAG,QAAQ,CAAC,IAAT,EAAX;;AACA,UAAI,IAAI,CAAC,IAAT,EAAe;AACb,QAAA,WAAW,CAAC,QAAZ;AACA;AACD;;AACD,MAAA,WAAW,CAAC,IAAZ,CAAiB,IAAI,CAAC,KAAtB;;AACA,UAAI,WAAW,CAAC,MAAhB,EAAwB;AACtB;AACD;AACF,KAVD,QAUS,IAVT;AAWD,GAbM,MAaA,IAAI,MAAM,IAAI,OAAO,MAAM,CAAC,YAAA,CAAA,UAAD,CAAb,KAAqC,UAAnD,EAA+D;AACpE,QAAM,GAAG,GAAG,MAAM,CAAC,YAAA,CAAA,UAAD,CAAN,EAAZ;;AACA,QAAI,OAAO,GAAG,CAAC,SAAX,KAAyB,UAA7B,EAAyC;AACvC,MAAA,WAAW,CAAC,KAAZ,CAAkB,IAAI,SAAJ,CAAc,gEAAd,CAAlB;AACD,KAFD,MAEO;AACL,aAAO,GAAG,CAAC,SAAJ,CAAc,IAAI,iBAAA,CAAA,eAAJ,CAAoB,eAApB,EAAqC,UAArC,EAAiD,UAAjD,CAAd,CAAP;AACD;AACF,GAPM,MAOA;AACL,QAAM,KAAK,GAAG,UAAA,CAAA,QAAA,CAAS,MAAT,IAAmB,mBAAnB,GAAyC,MAAI,MAAJ,GAAU,GAAjE;AACA,QAAM,GAAG,GAAG,kBAAgB,KAAhB,GAAqB,+BAArB,GACR,8DADJ;AAEA,IAAA,WAAW,CAAC,KAAZ,CAAkB,IAAI,SAAJ,CAAc,GAAd,CAAlB;AACD;;AACD,SAAO,IAAP;AACD;;AApEe,OAAA,CAAA,iBAAA,GAAiB,iBAAjB","sourcesContent":["import { root } from './root';\nimport { isArrayLike } from './isArrayLike';\nimport { isPromise } from './isPromise';\nimport { isObject } from './isObject';\nimport { Subscriber } from '../Subscriber';\nimport { Observable, ObservableInput } from '../Observable';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { Subscription } from '../Subscription';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function subscribeToResult<T, R>(outerSubscriber: OuterSubscriber<T, R>,\n                                        result: any,\n                                        outerValue?: T,\n                                        outerIndex?: number): Subscription;\nexport function subscribeToResult<T>(outerSubscriber: OuterSubscriber<any, any>,\n                                     result: ObservableInput<T>,\n                                     outerValue?: T,\n                                     outerIndex?: number): Subscription {\n  let destination: Subscriber<any> = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\n  if (destination.closed) {\n    return null;\n  }\n\n  if (result instanceof Observable) {\n    if (result._isScalar) {\n      destination.next((<any>result).value);\n      destination.complete();\n      return null;\n    } else {\n      destination.syncErrorThrowable = true;\n      return result.subscribe(destination);\n    }\n  } else if (isArrayLike(result)) {\n    for (let i = 0, len = result.length; i < len && !destination.closed; i++) {\n      destination.next(result[i]);\n    }\n    if (!destination.closed) {\n      destination.complete();\n    }\n  } else if (isPromise(result)) {\n    result.then(\n      (value) => {\n        if (!destination.closed) {\n          destination.next(<any>value);\n          destination.complete();\n        }\n      },\n      (err: any) => destination.error(err)\n    )\n    .then(null, (err: any) => {\n      // Escaping the Promise trap: globally throw unhandled errors\n      root.setTimeout(() => { throw err; });\n    });\n    return destination;\n  } else if (result && typeof result[Symbol_iterator] === 'function') {\n    const iterator = <any>result[Symbol_iterator]();\n    do {\n      let item = iterator.next();\n      if (item.done) {\n        destination.complete();\n        break;\n      }\n      destination.next(item.value);\n      if (destination.closed) {\n        break;\n      }\n    } while (true);\n  } else if (result && typeof result[Symbol_observable] === 'function') {\n    const obs = result[Symbol_observable]();\n    if (typeof obs.subscribe !== 'function') {\n      destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n    } else {\n      return obs.subscribe(new InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n    }\n  } else {\n    const value = isObject(result) ? 'an invalid object' : `'${result}'`;\n    const msg = `You provided ${value} where a stream was expected.`\n      + ' You can provide an Observable, Promise, Array, or Iterable.';\n    destination.error(new TypeError(msg));\n  }\n  return null;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}